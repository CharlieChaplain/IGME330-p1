
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>Amorphious++</title>
	<style>
        body {
            background: #000;
            font-family: tahoma, verdana, sans serif;
            margin: 0;
            color: #aab;
        }
        canvas {
            margin: auto;
            margin-top: 20px;
            margin-bottom: 20px;
            background: black;
            display: block;
            color: #556;
            border-color: #556;
            border-width: 15px;
            border-style: solid;
            box-shadow: 5px 5px 8px #112 inset;
            border-radius: 20px;
        }        
        h1{
            font-family: recharge;
            font-size: 50pt;
            text-shadow: 2px 2px 1px #112, -2px -2px 1px #eef;
            
        } 
        hr{
            clear:both;
        }
        footer{
            padding: 20px;
            margin: 20px;
            color: #556;
            background: #bbc;
            text-align: center;
            font-family: nasalization;
            border-color: #556;
            border-width: 15px;
            border-style: solid;
            font-size: 20pt;
            clear: both;
            box-shadow: 5px 5px 8px #112 inset;
            border-radius: 20px;
            text-shadow: 1px 1px 1px #112, -1px -1px 1px #eef;
        }
     
      
        
	</style>
	<script>
    // PROGRAMMED BY Joel Petritsch AND Stephen Callen
	// An IIFE ("Iffy") - see the notes in mycourses
	(function(){
		"use strict";	
		

		var canvas,ctx;     
        var timeLeft=0;
        var lastTime = 0; //used by calculateDeltaTime
        var dt;
        var angle =0;
        var swordAngle;
        var player = {
            x:100,
            y:100,
            img: undefined,
            animations: [],
            currentAnimation: undefined
        };
        var enemies = [];
        var mouse = {
            x:undefined,
            y:undefined
        }
         var movementVector = {
            x:undefined,
            y:undefined
        }
        function Animation(image, numFrames, secondsPerFrame, frameWidth, frameHeight){
            this.image = image;
            this.numFrames = numFrames;
            this.spf = secondsPerFrame;
            this.width = frameWidth;
            this.height = frameHeight;
            this.currentFrame = 0;
            this.animTimer = 0;
        }
        Animation.prototype.updateAnimation = function(){
            this.animTimer += dt;
            if(this.animTimer >= this.spf){
                this.animTimer = 0;
                if(this.currentFrame >= this.numFrames - 1){
                    this.currentFrame = 0;
                }
                else{
                    this.currentFrame++;
                }
            }
        }
        Animation.prototype.drawAnimation = function(ctx, x, y){
            ctx.drawImage(this.image, this.width * this.currentFrame, 0, this.width, this.height, x, y, this.width, this.height);
        }
        
        function doMouseMove(e){        
            mouse.x = e.pageX - e.target.offsetLeft;
            mouse.y = e.pageY - e.target.offsetTop;
        }
        function doMouseDown(e){        
            if(timeLeft==0){
             timeLeft = 1;
            }
        }
   
        
		function init(){
			// set up canvas stuff
			canvas = document.querySelector('canvas');
			ctx = canvas.getContext("2d");	
			
            player.img = document.getElementById("player");
            var walkAnim = new Animation(player.img, 4, 0.25, 46, 46);
            player.animations.push(walkAnim);
            player.currentAnimation = player.animations[0];
            
			// start animation loop
			update();
            canvas.onmousemove = doMouseMove;
            canvas.onmousedown = doMouseDown;
           
            
		}
		
		
	   
		
		
		
		function update() { 
			// this schedules a call to the update() method in 1/60 seconds
            dt = calculateDeltaTime();
            ctx.fillRect(0,0,1024,768)
			
            
            movePlayer();
            updateEnemies()
			requestAnimationFrame(update);            
           
			
		}
        function movePlayer(){     
            if(timeLeft ==0){//if we can move, move
                
                movementVector.x = mouse.x - player.x;
                movementVector.y = mouse.y - player.y;
                var magnitude = (movementVector.x * movementVector.x) + (movementVector.y * movementVector.y);
                magnitude = Math.sqrt(magnitude);//always move a specific speed
                
                angle = Math.atan2(movementVector.y, movementVector.x)
              
                
                if(Math.abs(movementVector.x)> 26){// if we are more than like, 3 pixels away
                    player.x = player.x + dt*movementVector.x*300/magnitude;//actually move player
                }
                if(Math.abs(movementVector.y)> 26){// if we are more than like, 3 pixels away
                    player.y = player.y +  dt*movementVector.y*300/magnitude;//Move player normalized distance
                }                
            }
            else{//otherwise, just swing the weapon.
            timeLeft-= dt;
                if(timeLeft < 0){
                    timeLeft = 0;
                }
            }
            
           
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(angle);
            ctx.translate(-13, -26); 
            player.currentAnimation.updateAnimation();
            player.currentAnimation.drawAnimation(ctx, 0, 0);  
            ctx.translate(13, 26);
            if(timeLeft>0){       
                swordAngle = angle + ((-1+timeLeft) * Math.PI) ;
                if(swordAngle< 0){
                        swordAngle+= Math.PI*2//0 is straight down
                    }
                swordAngle -= Math.PI/2;//update sword for collisions
                if(swordAngle< 0){
                        swordAngle+= Math.PI*2//0 is straight down
                    }
               
                ctx.rotate(((-1+timeLeft) * Math.PI));               
            }
            ctx.beginPath();            
            ctx.strokeStyle = "red";
            ctx.moveTo(0,0);
            ctx.lineTo(0,100);
            ctx.stroke();
            ctx.restore();
                
        }
        
        function updateEnemies(){
            var toDelete = -1;
            while(enemies.length < 3){
                var temp ={
                    x : Math.random() * 1024,
                    y : Math.random() * 768,
                    DeltaX : (Math.random()-.5) * 600,
                    DeltaY : (Math.random()-.5) * 600, 
                    img : document.getElementById("Blob"),
                    type : 0,
                    radius: 16
                    
                }
                var Determinator = Math.random()*4;
                Determinator = Math.trunc(Determinator);// Determine Spawn Location
                switch(Determinator){
                    case 1:
                        temp.x =0;
                        if(temp.DeltaX < 0){
                            temp.DeltaX *=-1;
                        }
                        break;
                    case 2:
                        temp.x=1024;
                        if(temp.DeltaX > 0){
                            temp.DeltaX *=-1;
                        }
                        temp.img = document.getElementById("BluBlob")
                        break;
                    case 3:
                        temp.y=0;
                         if(temp.DeltaY < 0){
                            temp.DeltaY*=-1;
                        }
                         temp.img = document.getElementById("RedBlob")
                        break;
                    default:
                        if(temp.DeltaY > 0){
                            temp.DeltaY*=-1;
                        }
                        temp.y = 768;
                        break;
                }
                
                Determinator = Math.random()*3;//Determine enemy Type
                Determinator = Math.trunc(Determinator);
                switch(Determinator){                  
                    case 1:                       
                        temp.img = document.getElementById("BluBlob")
                        temp.type = 1;
                        break;
                    case 2:
                        temp.img = document.getElementById("RedBlob")
                        temp.type = 2;
                        break;
                    default:                      
                        break;
                }
                
                
                
                
                
                console.dir(temp);
                enemies.push(temp);
            }
            
            for(var i =0; i < 3; i++){
                if(enemies[i].x < 0 || enemies[i].x > 1024 || enemies[i].y < 0 || enemies[i].y > 768){//if we go off screen, delete this next frame
                    toDelete = i;
                }
                else{//if we are still on screen
                    var enemyAngle = {x:0,y:0,magnitude:0,angle:0};
                    enemyAngle.x= player.x - enemies[i].x;
                    enemyAngle.y = player.y - enemies[i].y;
                    enemyAngle.magnitude = Math.sqrt((enemyAngle.x* enemyAngle.x) + (enemyAngle.y * enemyAngle.y));
                    enemyAngle.angle = Math.atan2(enemyAngle.y, enemyAngle.x);
                    if(enemyAngle.angle < 0){//edit angle for matchmaking
                        enemyAngle.angle += Math.PI*2                    
                    }
                    
                    
                     switch(enemies[i].type){
                           case 1:
                                var myAngle=0, deltaAngle=0;
                             
                                myAngle = Math.atan2(enemies[i].DeltaY, enemies[i].DeltaX ); 
                                deltaAngle = Math.max(Math.min((enemyAngle.angle - myAngle), .3)-.3);
                                console.log(deltaAngle);
                                myAngle = myAngle + deltaAngle;
                                console.log(myAngle);
                                 enemies[i].DeltaX = Math.cos(myAngle)*200;
                                enemies[i].DeltaY = Math.sin(myAngle)*200;
                             
                                enemyAngle.angle = Math.atan2(enemies[i].DeltaY, enemies[i].DeltaX);
                                if(enemyAngle.angle < 0){//edit angle for matchmaking
                                    enemyAngle.angle += Math.PI*2                    
                                }
                                break;
                           case 2:
                               
                               break;
                           default:
                             
                               break;
                       }
                                       
                    
                    
                    if( timeLeft > 0){//if we are swinging
                        var anglediff = Math.abs(enemyAngle.angle - swordAngle) * 180/Math.PI;
                        if(( anglediff < 10) && (enemyAngle.magnitude < 120)){//collision check
                            toDelete =i;
                        }
                    }
                    enemies[i].x += enemies[i].DeltaX*dt;
                    enemies[i].y += enemies[i].DeltaY*dt;
                }
                ctx.save();
                ctx.translate(-19,-17)
                ctx.drawImage(enemies[i].img, enemies[i].x, enemies[i].y)
                ctx.restore();
            }               
            if(toDelete != -1){
                enemies.splice(toDelete, 1);
            }
            
            
        }
        
		
		// HELPERS
		function makeColor(red, green, blue, alpha){
   			var color='rgba('+red+','+green+','+blue+', '+alpha+')';
   			return color;
		}
        function calculateDeltaTime(){
            var now,fps;
            now = performance.now(); 
            fps = 1000 / (now - lastTime);
            fps = clamp(fps, 12, 60);
            lastTime = now; 
            return 1/fps;
	    }        
        function clamp(val, min, max){
	        return Math.max(min, Math.min(max, val));
        }       
      
		 // FULL SCREEN MODE
		function requestFullscreen(element) {
			if (element.requestFullscreen) {
			  element.requestFullscreen();
			} else if (element.mozRequestFullscreen) {
			  element.mozRequestFullscreen();
			} else if (element.mozRequestFullScreen) { // camel-cased 'S' was changed to 's' in spec
			  element.mozRequestFullScreen();
			} else if (element.webkitRequestFullscreen) {
			  element.webkitRequestFullscreen();
			}
			// .. and do nothing if the method is not supported
		};
		
		window.addEventListener("load",init);
    }());
		
	</script>
</head>
<body>
    <img src="CharacterV2.png" id="player">
    <img src="AngeryBoi.png" id="Blob">
    <img src="RedBoi.png" id="RedBlob">
    <img src="BluBoi.png" id="BluBlob">
    <canvas id="canvas" width="1024" height="768"></canvas>  
	
    <footer>
        <p>Joel Petritsch, Stephen Callen | 2018</p>        
    </footer>
</body>
    
</html>
