<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>Web Audio Visualizer</title>
	<style>
	body {
         background: #eeeeee;
         font-family: tahoma, verdana, sans serif;
      }

      canvas {
        margin-left:10px;
        margin-top:10px;
        box-shadow: 4px 4px 8px rgba(0,0,0,0.5);
        background: black;
    }
      
      #controls{
      	margin-left:10px;
        margin-top:10px;
      }
	</style>
	<script>
	// An IIFE ("Iffy") - see the notes in mycourses
	(function(){
		"use strict";
		
		var NUM_SAMPLES = 256;
		var SOUND_1 = 'media/New Adventure Theme.mp3';
		var SOUND_2 = 'media/Peanuts Theme.mp3';
		var SOUND_3 = 'media/The Picard Song.mp3';
		var audioElement;
		var analyserNode;
		var canvas,ctx;
        var maxRadius=200;
        var invert = false, tintRed=false, noise=false, lines =false, doBoost=false;
		var delayAmount = 0.5;
        var delayNode;
        var bassFilter;
        var trebleFilter;
        
        
		function init(){
			// set up canvas stuff
			canvas = document.querySelector('canvas');
			ctx = canvas.getContext("2d");
			
			// get reference to <audio> element on page
			audioElement = document.querySelector('audio');
			
			// call our helper function and get an analyser node
			analyserNode = createWebAudioContextWithAnalyserNode(audioElement);
			
			// get sound track <select> and Full Screen button working
			setupUI();
			
			// load and play default sound into audio element
			playStream(audioElement,SOUND_1);
			
			// start animation loop
			update();
		}
		
		
		function createWebAudioContextWithAnalyserNode(audioElement) {
			var audioCtx, analyserNode, sourceNode;
			// create new AudioContext
			// The || is because WebAudio has not been standardized across browsers yet
			// http://webaudio.github.io/web-audio-api/#the-audiocontext-interface
			audioCtx = new (window.AudioContext || window.webkitAudioContext);		
           
            bassFilter =audioCtx.createBiquadFilter();
            bassFilter.type = "lowshelf";
            bassFilter.frequency.vale = 200;
            if(doBoost){
            bassFilter.gain.value=40;
            }
            else{
                bassFilter.gain.value =0;
            }
            trebleFilter = audioCtx.createBiquadFilter();
            trebleFilter.type = "highshelf";
            trebleFilter.frequency.value = 2000;
            trebleFilter.gain.value =0;
            
            
            
			// create an analyser node
			analyserNode = audioCtx.createAnalyser();
			
            delayNode =audioCtx.createDelay();
            delayNode.delayTime.Value =delayAmount;
			// fft stands for Fast Fourier Transform
			analyserNode.fftSize = NUM_SAMPLES;
			
			// this is where we hook up the <audio> element to the analyserNode
			sourceNode = audioCtx.createMediaElementSource(audioElement); 
			//sourceNode.connect(analyserNode);
            //Source node goes straight to speakers, unaltered.
            sourceNode.connect(audioCtx.destination);
            
            //channel will play and visualize the delay
            sourceNode.connect(bassFilter);
            bassFilter.connect(trebleFilter);
            trebleFilter.connect(delayNode);
            delayNode.connect(analyserNode);
            
            
			
			// here we connect to the destination i.e. speakers
			analyserNode.connect(audioCtx.destination);
			return analyserNode;
		}
		
		function setupUI(){
			document.querySelector("#trackSelect").onchange = function(e){
				playStream(audioElement,e.target.value);
			};
			
			document.querySelector("#fsButton").onclick = function(){
				requestFullscreen(canvas);
			};
             document.querySelector("#slider1").onchange = function(e){			 	
			 	 document.querySelector("#sliderResults").innerHTML = e.target.value;
                 maxRadius = e.target.value;
                 console.log(maxRadius);                 
			 };
             document.querySelector("#delaySlider").onchange = function(e){	
                 delayAmount = e.target.value;
                 console.log(delayAmount);
			 };
            document.getElementById("boostCheck").onchange = function(e){	
                 if( e.target.checked){
				 	doBoost=true;                     
                bassFilter.gain.value=40;          
                }				
                else{
                    doBoost= false;
                     bassFilter.gain.value =0; 
                }		
			 };
            document.getElementById('RedCheck').onchange = function(e){
				if( e.target.checked){
				 	tintRed=true;
				}
                else{
                    tintRed = false;
                }				
			};
            document.getElementById('InvertCheck').onchange = function(e){
				if( e.target.checked){
				 	invert=true;
				}
                else{
                    invert = false;
                }				
			};	
            document.getElementById('NoiseCheck').onchange = function(e){
				if( e.target.checked){
				 	noise=true;
				}
                else{
                    noise = false;
                }				
			};	
            document.getElementById('LineCheck').onchange = function(e){
				if( e.target.checked){
				 	lines=true;
				}
                else{
                    lines = false;
                }				
			};	
		}
		
		function playStream(audioElement,path){
			audioElement.src = path;
			audioElement.play();
			audioElement.volume = 0.2;
			document.querySelector('#status').innerHTML = "Now playing: " + path;
		}
		
		function update() { 
			// this schedules a call to the update() method in 1/60 seconds
			requestAnimationFrame(update);
			
			/*
				Nyquist Theorem
				http://whatis.techtarget.com/definition/Nyquist-Theorem
				The array of data we get back is 1/2 the size of the sample rate 
			*/
			
			// create a new array of 8-bit integers (0-255)
			var data = new Uint8Array(NUM_SAMPLES/2); 
            delayNode.delayTime.value = delayAmount;
			
			// populate the array with the frequency data
			// notice these arrays can be passed "by reference" 
			analyserNode.getByteFrequencyData(data);
		
			// OR
			//analyserNode.getByteTimeDomainData(data); // waveform data
			
			// DRAW!
			ctx.clearRect(0,0,800,600);  
			var barWidth = 4;
			var barSpacing = 1;
			var barHeight = 100;
			var topSpacing = 50;            
            var lastY = window.innerHeight/2;
            var lastX =0;
			
			// loop through the data and draw!
			for(var i=0; i<data.length; i++) { 
				ctx.fillStyle = 'rgba(0,255,0,0.6)'; 
				
				// the higher the amplitude of the sample (bin) the taller the bar
				// remember we have to draw our bars left-to-right and top-down
             
				//ctx.fillRect(i * (barWidth + barSpacing),topSpacing + 256-data[i],barWidth,barHeight); 
				//ctx.fillRect(640-i*(barWidth+barSpacing),topSpacing+256-data[i]-20,barWidth,barHeight);
                //red-ish circles 
                var percent=data[i]/255;
               
                var circleRadius=percent*maxRadius;
                ctx.beginPath();
                ctx.fillStyle=makeColor(255,111,111,.34-percent/3.0);
                ctx.arc(canvas.width/2,canvas.height/2,circleRadius,0,2*Math.PI,false);
                ctx.fill();
                ctx.closePath();
                //blue-ish circles, bigger,more transparent
                ctx.beginPath();
                ctx.fillStyle=makeColor(0,0,255,.10-percent/10.0);
                ctx.arc(canvas.width/2,canvas.height/2,circleRadius*1.5,0,2*Math.PI,false);
                ctx.fill();
                ctx.closePath();
                //yellow-ishcircles,smaller 
                ctx.save();
                ctx.beginPath();
                ctx.fillStyle=makeColor(200,200,0,.5-percent/5.0);
                ctx.arc(canvas.width/2,canvas.height/2,circleRadius*.50,0,2*Math.PI,false);
                ctx.fill();
                ctx.closePath();
                ctx.restore();
            }
            for(var i=0; i<data.length; i++) { 
                ctx.strokeStyle="green";                
                ctx.lineWidth= 4;
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo((i+1) * (barWidth), topSpacing+256-data[i]);
                lastX =(i+1) * (barWidth);
                lastY = topSpacing+256-data[i];
                ctx.closePath();
                ctx.stroke();
			}
            manipulatePixels();
			 
		} 
        
        function manipulatePixels(){
            var imgData = ctx.getImageData(0,0,canvas.width, canvas.height);
            
            var data= imgData.data;
            var length = data.length;
            var width = imgData.width;
            
            for (var i=0; i< length; i+=4){
                if(tintRed){
                    data[i] += 100;
                }
                if(invert){
                    var red = data[i], green = data[i+1], blue = data[i+2];
                    data[i]=255-red;
                    data[i+1]=255-green;
                    data[i+2]=255-blue;
                }
                if(noise){
                    if(Math.random() < .09){
                        data[i]=data[i+1]=data[i+2]=0;//black noise
                    }
                }
                if(lines){
                    var row=Math.floor(i/4/width);
                    
                    if(row % 50 == 0){
                        
                        //this row 
                        data[i]=data[i+1]=data[i+2]=data[i+3]=255;
                        //next row 
                        data[i+(width*4)]=
                        data[i+(width*4)+1]=
                        data[i+(width*4)+2]=
                        data[i+(width*4)+3]=255;
                    }
                }
            }
            ctx.putImageData(imgData,0,0);
            
        }
		
		// HELPER
		function makeColor(red, green, blue, alpha){
   			var color='rgba('+red+','+green+','+blue+', '+alpha+')';
   			return color;
		}
		
		 // FULL SCREEN MODE
		function requestFullscreen(element) {
			if (element.requestFullscreen) {
			  element.requestFullscreen();
			} else if (element.mozRequestFullscreen) {
			  element.mozRequestFullscreen();
			} else if (element.mozRequestFullScreen) { // camel-cased 'S' was changed to 's' in spec
			  element.mozRequestFullScreen();
			} else if (element.webkitRequestFullscreen) {
			  element.webkitRequestFullscreen();
			}
			// .. and do nothing if the method is not supported
		};
		
		
		window.addEventListener("load",init);
	}());
		
	</script>
</head>
<body>
	<canvas id="canvas" width="640" height="400"></canvas>
	<div id="controls">
		<audio controls loop></audio>
		<label>Track: 
			<select id="trackSelect" >
				<option value="media/New Adventure Theme.mp3">New Adventure Theme</option>
				<option value="media/Peanuts Theme.mp3">Peanuts Theme</option>
				<option value="media/The Picard Song.mp3">The Picard Song</option>
                <option value="media/07 Touch (feat. Paul Williams).mp3">Touch</option>
                          

			</select>
		</label>
		<button id="fsButton">Go Full Screen</button><br>
        <div>
		          <label for="slider1">Radius</label>
		          <input id="slider1" type ="range" min ="50" max="400.0" step ="10" value ="200"/>
		          <span style="float:right" id="sliderResults">???</span>
            <p>
                <label>
                    Delay/Reverb
                    <input id="delaySlider" type="range" min="0.0" max="2.5" step ="0.1">
                </label>               
            </p>
	   </div>      
		<p id="status">???</p>
        <div>
		<span>
			<label for="myCheckbox">Tint-Red</label>
			<input type="checkbox" id="RedCheck">
            <label for="myCheckbox">Noise</label>
			<input type="checkbox" id="NoiseCheck">
            <label for="myCheckbox">Invert</label>
			<input type="checkbox" id="InvertCheck">
            <label for="myCheckbox">Lines</label>
			<input type="checkbox" id="LineCheck">
            <label for="myCheckbox">BOOST</label>
			<input type="checkbox" id="boostCheck">
		</span>
	</div>
</body>
</html>
